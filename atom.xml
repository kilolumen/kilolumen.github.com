<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kilolumen</title>
  
  
  <link href="http://www.ioswifter.com/atom.xml" rel="self"/>
  
  <link href="http://www.ioswifter.com/"/>
  <updated>2021-07-07T07:09:03.116Z</updated>
  <id>http://www.ioswifter.com/</id>
  
  <author>
    <name>DJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.ioswifter.com/2021/07/07/hello-world/"/>
    <id>http://www.ioswifter.com/2021/07/07/hello-world/</id>
    <published>2021-07-07T07:09:03.116Z</published>
    <updated>2021-07-07T07:09:03.116Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Install Hexo</title>
    <link href="http://www.ioswifter.com/2018/10/10/Install-Hexo/"/>
    <id>http://www.ioswifter.com/2018/10/10/Install-Hexo/</id>
    <published>2018-10-10T08:59:50.000Z</published>
    <updated>2021-07-07T07:09:03.115Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><ul><li>Git</li><li>Node.js</li></ul><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ npm install hexo --save</span><br></pre></td></tr></table></figure><p>部署Hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;folder&gt;</span><br><span class="line">cd &lt;folder&gt;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装Hexo 插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;h3 id=&quot;安装前提&quot;&gt;&lt;a href=&quot;#安装前提&quot; class=&quot;headerlink&quot; title=&quot;安装前提&quot;&gt;&lt;/a&gt;安装前提&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Git&lt;/li&gt;
&lt;li&gt;Node.js&lt;/li&gt;
&lt;/ul&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git 常用命令及使用场景</title>
    <link href="http://www.ioswifter.com/2017/08/04/git-cli/"/>
    <id>http://www.ioswifter.com/2017/08/04/git-cli/</id>
    <published>2017-08-04T01:52:18.000Z</published>
    <updated>2021-07-07T07:09:03.116Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本文只写git命令相关内容，git安装及配置<a href="https://git-scm.com/%E3%80%81github%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BArepository%E3%80%81%E6%B7%BB%E5%8A%A0ssh%E7%AD%89%EF%BC%8C%E8%AF%B7%E5%88%B0https://help.github.com/">https://git-scm.com/、github如何创建repository、添加ssh等，请到https://help.github.com/</a></p><p>以github作为远程仓库托管平台为例：</p><p>如果本地项目已经创建好，在github上创建好仓库（最好和项目同名）</p><p>本地切换到项目主目录 cd <path><br>git init     //创建初始化仓库<br>git add .        // 把工作区的修改的内容存入暂存区<br>git commit -m “提交信息”    // 把暂存区的文件保存为一个commit<br>git remote add origin <path>    // 添加远程仓库地址<br>git push -f origin master        // 把本地仓库修改push到远程仓库</p><p>如果已经有远程仓库：<br>git clone <repo_address>    // 把远程仓库克隆到本地</p><p>这里解释两个名词：<br>工作区：刚刚修改的文件，是被存储在工作区的。可以使用git status查看修改的文件，或者使用git diff查看修改的文件的详细内容<br>暂存区：一个缓存区，临时保存你的改动，git add 之后会把工作区的文件存入暂存区。可以执行git status查看分别存在工作区和暂存区修改的文件。存入暂存区后git diff就不能查看了，这时你可以执行git reset <filename>把暂存区的内容保存后工作区</p><p>基础使用：<br>下面逐个命令分析：</p><p>首先执行<br>git init<br>创建并初始化git仓库</p><p>创建仓库后，你可以执行：<br>git status<br>查看改动了那些文件</p><p>如果想看每个文件的具体改动，可以<br>git diff <filename></p><p>全部改动<br>git diff<br>但是查看改动的文件，只能在工作区，如果被添加到暂存区，就看不到了<br>我们可以把暂存区的改动撤销到工作区，请看下面的git reset</p><p>修改完成后，执行<br>git add <filename><br>把工作区中你修改的要提交的文件添加到暂存区</p><p>或者使用如下命令：<br>git add .<br>把工作区的全部修改添加到暂存区</p><p>更高级一点，你可以交互式的添加<br>git add -i</p><p>使用如下命令提交你的改动：<br>git commit -m “提交信息”</p><p>如果你想添加和提交一条命令：<br>git commit -am “提交信息”</p><p>假如你的”提交信息”输入错误，你可以执行：<br>git commit –amend<br>会进入你配置的编辑器，然后你可以修改你的”提交信息”。比如设置vim为编辑器<br>git config –global core.editor vim<br>git config –global core.editor /usr/bin/vim</p><p>或者直接<br>git commit –amend -m “新的提交信息”</p><p>提交完修改后，发现工作区有漏掉的文件没有提交，或者想把新修改的文件添加到最新的一次本地commit，你需要：<br>git add .<br>git commit –amend<br>这样，你的漏掉或者新的改动就会提交到最新的一次本地commit</p><p>你的改动现在只保存在本地仓库，执行如下命令可以推送你的改动到远端仓库<br>git push origin master<br>有时可能会push失败，需要（谨慎使用）<br>git push -f origin master<br>强制推送</p><p>如果你没有添加远端仓库地址，你可以执行<br>git remote add origin &lt;<a href="mailto:&#103;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;">&#103;&#x69;&#116;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#x62;&#46;&#99;&#x6f;&#109;</a>:you_github_name/you_repository_name.git&gt;<br>添加远程仓库地址</p><p>如果远程仓库别人有新的提交，你可以执行：<br>git pull<br>同步到你的本地仓库。第一次pull时，这时候可能会错误，按照错误提示修改一些就好了</p><p>分支（branch）：<br>多人协作工作时，一般会基于主分支创建自己的分支，执行自己的任务。任务完成后再把自己的分支合并到主分支。</p><p>你可以执行如下命令：<br>git branch<br>查看本地分支，或者<br>git branch -a<br>查看本地及远程分支</p><p>你可以基于当前分支创建新的分支，如新分支命名为new_branch<br>git branch <new_branch><br>或者基于指定的分支branch，创建新的分支new_branch<br>git branch <new_branch> <branch></p><p>创建好分支后，切换到新分支new_branch<br>git checkout <new_branch></p><p>以上两步可以用一条命令代替，创建新分支，并切换到新分支<br>git checkout -b <new_branch><br>或者<br>git checkout -b <new_branch> <branch></p><p>分支创建好后，只存在本地，只能自己看到，如果想同步到远程<br>git push origin <new_branch> <new_branch></p><p>git branch -v<br>可以查看每个分支最后的提交信息</p><p>如果你想删除某个分支，需要切换到其他分支，比如master:<br>git checkout master<br>再把新建的分支删掉：<br>git checkout -d <new_branch><br>当要删除的分支有为推送的commit时，删除失败，可以使用-D强制删除，如下<br>git checkout -D <new_branch></p><p>现在你知识删除了本地分支，远程的分支怎么删除呢，你可以执行：<br>git push origin :<new_branch><br>这行命令表示，你把一个空的分支同步到了new_branch，这样就删掉了</p><p>log:<br>如果你想查看本地仓库的提交记录，你可以执行<br>git log</p><p>你也可以添加一些参数，更精确的得到自己想要的结果，比如每条提交记录压缩为一行输出：<br>git log –pretty=oneline</p><p>只想查看某一个人的提交记录<br>git log –author=name</p><p>或者通过 ASCII 艺术的树形结构来展示所有的分支, 每个分支都标示了他的名字和标签<br>git log –graph –oneline –decorate –all</p><p>查看每次提交记录，改动了哪些文件<br>git log –name-status<br>想要查看更多参数，请参考：<br>git log –help</p><p>如果想要查看某个提交的改动的具体内容，可以执行<br>git show <commit_id></p><p>合并：<br>在你的分支完成任务，提交改动后，你需要把你的分支合并到主分支，如master：<br>git checkout master<br>合并前需要同步远程仓库到本地：<br>git pull<br>然后执行合并操作：<br>git merge <new_branch></p><p>合并前你可以查看改动前后的差异：<br>git diff master <new_branch></p><p>合并时冲突不是能完成避免的，产生冲突时如何你想撤销合并，执行，<br>git merge –abort<br>如果不想撤销，你可以解决冲突后，把工作区的文件暂存到暂存区：<br>git add .<br>然后继续完成合并：<br>git commit<br>然后把本地的更新推送的远程仓库：<br>git push</p><p>a -&gt; b -&gt; c -&gt; f – g -&gt; h (master)<br>               \          /<br>              d -&gt; e  (new_branch)</p><p>如上图，合并后生成新的commit_id: f</p><p>如果此时发现有bug，你想撤销合并，可以执行：<br>git reset –hard f</p><p>或者，使用revert撤销合并的内容:<br>git revert -m 1 g<br>（m指定主线，1代表parent）会生成一个新的提交G，如下图：<br>a -&gt; b -&gt; c -&gt; f – g -&gt; h -&gt; G (master)<br>                  \          /<br>                d -&gt; e  (new_branch)</p><p>如果new_branch的bug修改后，<br>a -&gt; b -&gt; c -&gt; f – g -&gt; h -&gt; G -&gt; i (master)<br>               \             /<br>               d -&gt; e -&gt; j -&gt; k (new_branch)<br>如果你直接合并，会丢失d和e的提交信息，所以你需要<br>git checkout master<br>git revert G<br>git merge new_branch<br>完成后，如下图：<br>a -&gt; b -&gt; c -&gt; f – g -&gt; h -&gt; G -&gt; i -&gt; G’ – m (master)<br>                 \            /                                       /<br>               d -&gt; e -&gt; j -&gt; k —————    (dev)</p><p>你可以用rebase进行合并，也就是变基操作，而且会减少不必要的合并信息，产生一个更简洁的提交历史：<br>git rebase master new_branch<br>git checkout master<br>git merge new_branch</p><p>有时候，我们需要把自己分支的某一个commit，合并到主分支，<br>git checkout master<br>git cherry-pick commit_id</p><p>合并某个分支上一系列相连的commits：<br>在一些特定情况下，合并单个commit并不够，你需要合并一系列相连的commits。这种情况下就不要选择cherry-pick了，rebase更适合。假如你需要合并feature分支的commit 23kj23j4~ak1kj23到master分支，首先你需要基于feature创建一个新的分支，并指明新的分支的最后一个commit：<br>git checkout -b new_branch ak1kj23</p><p>然后，rebase这个新分支的commit到master。23kj23j4^指明你想从哪个特定的commit开始。<br>git rebase –onto=master 23kj23j4^<br>得到的结果就是feature分支的commit 23kj23j4~ak1kj23都被合并到了master分支</p><p>修改改动：<br>有时我们会把暂存区的内容，想要查看改动的内容，或者不想本次提交，想要分两次提交，可以执行：<br>git checkout <filename><br>把暂存区的文件撤销到工作区</p><p>假如你想丢弃到本次的所有改动（工作区和暂存区），可以执行：<br>git reset –hard<br>撤销所有未commit的改动</p><p>如果你想撤销最后一次提交（未推送到远程），可以执行：<br>git reset HEAD^<br>撤销最后一次提交（未push的远程）到工作区，如果已push到远程，会创建一个新的commit，同revert</p><p>你也撤销指定的commit_id之后的所有提交，并把改动内容撤销到工作区<br>git reset commit_id</p><p>也可以直接抛弃掉：<br>git reset –hard commit_id</p><p>如果要丢弃掉所有本地改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它<br>git reset –hard origin/master</p><p>如果想回退版本后，再修改回来，你需要使用<br>git revert<br>进行版本回退，会产生一个新的提交内容G<br>如果想修改回来，再执行：<br>git revert G<br>就可以了</p><p>你可以撤销前一次的commit：<br>git revert HEAD</p><p>或者撤销前前一次的commit：<br>git revert HEAD^</p><p>甚至撤销指定的commit<br>git revert commit-id</p><p>储藏（stash）：<br>有时我们改动的文件后，想要更新远程的改动、或者不想提交需要先保存起来、或者想要应用到不同的分支，这是我们可以使用：<br>git stash</p><p>我们可知储藏的改动添加说明信息：<br>git stash save “说明嘻嘻”</p><p>也可以查看储藏几条：<br>git stash list</p><p>可以查看每一条改动的文件：<br>git stash show <stash_id></p><p>或者把某一个储藏内容，应用到当前分支，并不从储藏室删除：<br>git stash apply <stash_id></p><p>或者直接应用到分支，并且删除：<br>git stash pop<br>默认是最新的一条stash</p><p>也可指定stash：<br>git stash pop <stash_id></p><p>apply或者pop是可能会产生冲突，如果pop时产生冲突，就不会立即从储藏室删除了</p><p>如果想删除掉储藏室的某一条：<br>git stash drop <stash_id></p><p>或者直接清除储藏室：<br>git stash clear</p><p>查找：</p><p>如果想要查看文件的每个部分是谁修改的，那么git blame就是不二选择，可以看到每一行的详细修改信息：包括SHA串，日期和作者<br>git blame <filename></p><p>如果想查找某一段文字，比如 Macro_iPad<br>git grep Macro_iPad</p><p>还可以显示行号<br>git grep -n Macro_iPad</p><p>或者只显示文件名<br>git grep –name-only Macro_iPad</p><p>每个文件里有多少行匹配内容<br>git grep -c Macro_iPad</p><p>或者某个tag里的内容<br>git grep Macro_iPad v1.1.0</p><p>git bisect<br>有时你可能会遇到这种情况：<br>如果一个代码仓库中发现了一个bug，想要找到出现bug的commit，再修复bug时，可以使用git checkout到很久的一个commit，然后查看是否存在bug，如果没有再git checkout到这个commit和最新的commit中间的一个commit，查看是否存在bug，以这种二分查找法查找。是的，我最初是这么做的，现在我告诉你一个更方便的方法，git disect，git 自带的二分查找。<br>git bisect start<br>git bisect good <good_commit><br>git bisect bad <bad_commit><br>git bisect good<br>git bisect good<br>git bisect bad<br>git bisect good<br>……<br>git bisect reset     // 退出</p><p>git bisect最初是用于寻找bug的引入的坏点而不是fix bug的好点，如果某个bug被不知不觉的修复了，故想要查找修复的bug的commit时，只要把good和bad的概念颠倒一些就可以了<br>git bisect start<br>git bisect good <bad_commit><br>git bisect bad <good_commit><br>……<br>git bisect reset</p><p>git fsck -lost-found<br>commit删除后，变成dangling commit(悬空对象)，并不是真正的删除，只要把dangling commit(悬空对象)找出来，git rebase或git merge把他们恢复</p><p>其他：</p><p>查看远程仓库地址：<br>git remote -v</p><p>删除远程仓库：<br>git remote rm origin</p><p>添加多个远程仓库<br>git remote set-url –add origin <repo_address><br>可以在配置中查看<br>.git/config</p><p>有时远程别人的分支已经删除了，本地却还能看到，可以执行<br>git fetch -p<br>同步一下，这样本地也就没有了</p><p>软件发布时，推荐为每个版本创建一个标签，方便以后的管理<br>git tag 1.0 <commit_id></p><p>推荐的开发流程：<br>基于主分支创建自己的分支-&gt;完成任务后，提交commit-&gt;把自己的分支推送到github-&gt;在github上创建一个pull request-&gt;其他开发人员review-&gt;没有问题后合并到主分支</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;本文只写git命令相关内容，git安装及配置&lt;a href=&quot;https://git-scm.com/%E3%80%81github%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BArepositor</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>British Shorthair</title>
    <link href="http://www.ioswifter.com/2016/11/01/British-Shorthair/"/>
    <id>http://www.ioswifter.com/2016/11/01/British-Shorthair/</id>
    <published>2016-11-01T05:28:37.000Z</published>
    <updated>2021-07-07T07:09:03.114Z</updated>
    
    <content type="html"><![CDATA[<p>British Shorthair</p><span id="more"></span><p><img src="/images/BritishShorthair.jpg"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;British Shorthair&lt;/p&gt;</summary>
    
    
    
    <category term="生活" scheme="http://www.ioswifter.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="宠物" scheme="http://www.ioswifter.com/tags/%E5%AE%A0%E7%89%A9/"/>
    
  </entry>
  
  <entry>
    <title>Mac Keyboard shortcut</title>
    <link href="http://www.ioswifter.com/2016/07/22/Mac-Keyboard-shortcut/"/>
    <id>http://www.ioswifter.com/2016/07/22/Mac-Keyboard-shortcut/</id>
    <published>2016-07-22T12:08:47.000Z</published>
    <updated>2021-07-07T07:09:03.115Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>建议：System-&gt;键盘-&gt;修饰键-&gt;caps lock 改为control<br>shift+command+O 快捷搜索<br>shift+command+F 全局搜索<br>shift+command+J 跳到当前文件目录位置<br>shift+command+C 跳到控制台<br>command+K 清空控制台<br>control+A 行首<br>control+E 行尾<br>control+F 前（font）<br>control+B 后（back）<br>control+N 下（down）<br>control+P 上（up）<br>control+G 后一个word（自己配置）<br>control+H 前一个word（自己配置）<br>control+option+F 前跳<br>control+option+B 后跳<br>control+K 删除光标后的内容<br>control+delete 删除光标前一个单词<br>command+delete 删除光标前内容<br>command+L 跳到指定行<br>control+L 光标所在位置跳到中间<br>command+~ 切换工程<br>command+shift+【或】 标签切换<br>command+数字（1-8） <br>command+shift+Y 显示\隐藏控制台<br>command+数字0 显示\隐藏左导航<br>command+option+0 显示\隐藏右导航<br>command+shift+0 API文档<br>control+command+↑\↓ .h和.m切换<br>control+command+←\→ 浏览历史切换<br>按住option单击 点到定义的地方<br>按住command单击 窗口查看API<br>按住command双击 跳到文档查看API<br>shift+command+↑\↓\←\→ 选中（line，all）<br>shift+option+↑\↓\←\→ 选中或取消选中（word，line）<br>shift+←\→ 选中（char）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;建议：System-&amp;gt;键盘-&amp;gt;修饰键-&amp;gt;caps lock 改为control&lt;br&gt;shift+command+O 快捷搜索&lt;br&gt;shift+command+F 全局搜索&lt;br&gt;shift+comman</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>NSURLSessionDownloadTask后台下载遇到的几种情况</title>
    <link href="http://www.ioswifter.com/2016/06/13/NSURLSessionDownloadTask-usage/"/>
    <id>http://www.ioswifter.com/2016/06/13/NSURLSessionDownloadTask-usage/</id>
    <published>2016-06-13T15:22:14.000Z</published>
    <updated>2021-07-07T07:09:03.116Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>1、下载过程中如果直接crash，会在后台继续下载，下载完所有任务后，自动唤醒app，并依次调用：<br>application:didFinishLaunchingWithOptions:<br>application:handleEventsForBackgroundURLSession:completionHandler:<br>// 有几个任务调用几次下面两个方法<br>URLSession:downloadTask:didFinishDownloadingToURL: // 多次<br>URLSession:task:didCompleteWithError:   // 多次</p><p>URLSessionDidFinishEventsForBackgroundURLSession:<br>如果在下载完之前，进入前台，会继续下载，下载完的调用下面两个方法：<br>URLSession:downloadTask:didFinishDownloadingToURL:<br>URLSession:task:didCompleteWithError:</p><p>2、下载过程中直接kill掉app，会在后台重新唤醒，并cancel所有task，并调用：<br>application:didFinishLaunchingWithOptions:<br>application:handleEventsForBackgroundURLSession:completionHandler: // 多次</p><p>URLSession:task:didCompleteWithError:（可以保存下载中的resumedata） // 多次<br>URLSessionDidFinishEventsForBackgroundURLSession:<br>退出前应对未下载的数据进行保存</p><p>3、suspend所有task，crash后没有任何反应，重启后可以调用：<br>getTasksWithCompletionHandler<br>获得所有downloadTask然后调用resume继续下载</p><p>4、suspend所有task后，kill掉app，会在后台唤醒app，然后调用：<br>application:didFinishLaunchingWithOptions:<br>application:handleEventsForBackgroundURLSession:completionHandler: // 次数=task.count</p><p>URLSession:task:didCompleteWithError:（可以保存下载中的resumedata）  //次数=task.count<br>URLSessionDidFinishEventsForBackgroundURLSession:</p><p>4、下载过程中cancel，调用:<br>URLSession:task:didCompleteWithError：<br>然后从session中移除</p><p>5、下载过程中，退出app到后台，所有任务下载完后，调用<br>application:handleEventsForBackgroundURLSession:completionHandler:</p><p>URLSession:downloadTask:didFinishDownloadingToURL:   // 多次<br>URLSession:task:didCompleteWithError:                   // 多次</p><p>URLSessionDidFinishEventsForBackgroundURLSession:<br>如果进入前台时，任务还未下完，会继续下载</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;1、下载过程中如果直接crash，会在后台继续下载，下载完所有任务后，自动唤醒app，并依次调用：&lt;br&gt;application:didFinishLaunchingWithOptions:&lt;br&gt;application:</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么情况下使用NSOperationQueue</title>
    <link href="http://www.ioswifter.com/2016/04/22/NSOperationQueue-use/"/>
    <id>http://www.ioswifter.com/2016/04/22/NSOperationQueue-use/</id>
    <published>2016-04-22T13:50:46.000Z</published>
    <updated>2021-07-07T07:09:03.115Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>我个人非常喜欢用GCD，但是某些情况下一般会使用NSOperationQueue。<br>1、取消某个操作。<br>如果使用NSOperation，那么想要取消操作，只要任务运行之前，在NSOperation对象上调用cancel方法，但是无法取消已运行的任务。而GCD队列是无法取消的。<br>2、指定操作的优先级。<br>操作优先级表示操作与队列中其他操作之间的优先关系。优先级高的操作先执行，优先级低的后执行。GCD只有针对整个队列的优先级，没有针对每个block的优先级，需要自己编写调度算法，而NSOperationQueue所提供的功能要比GCD更为便利。NSOperation对象也有“线程优先级”，这决定了运行此操作的线程处在何种优先级上。用GCD也可以实现此功能，然而采用操作队列更简单，只需设置一个属性。<br>3、通过KVO监控NSOperation对象的属性。<br>NSOperation对象有许多属性都适合通过KVO来监听，比如可以通过isCancelled属性来判断任务是否已取消，又比如可以通过isFinished属性来判断任务是否已完成。如果想在某个任务变更其状态时得到通知，或是想用比GCD更为精细的方式来控制所要执行的任务，那么KVO机制会很有用。<br>4、重用NSOperation对象。<br>系统内设置了一些NSOperation的子类，比如NSBlockOperation，供开发者调用，我们也可以自己来创建。这些类就是普通的Objective-C对象，能够存放任何信息。对象在执行时可以充分利用存于其中的信息，而且还可以随意调用定义在类中的方法。这就比GCD中的那些简单的Block块要强大许多。这些NSOperation类可以在代码中多次使用，它们符合软件开发中的“不重复”原则。<br>5、指定操作间的依赖关系。<br>一个操作可能依赖其他多个操作。开发者能够指定操作之间的依赖关系，使特定的操作必须在另外一个操作顺利执行完毕之后方可执行。比如，从服务器端下载并处理文件的动作，可以用操作来表示，而在处理其他文件之前，必须先下载“清单文件”。后续的下载操作，都要依赖于下下载清单文件这一操作。如果操作队列允许并发的话，那么后续的多个下载操作就可以同时进行，但前提是它们所依赖的那个清单文件下载操作已经执行完毕。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;我个人非常喜欢用GCD，但是某些情况下一般会使用NSOperationQueue。&lt;br&gt;1、取消某个操作。&lt;br&gt;如果使用NSOperation，那么想要取消操作，只要任务运行之前，在NSOperation对象上调用ca</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>产品记事</title>
    <link href="http://www.ioswifter.com/2016/04/18/notes-1/"/>
    <id>http://www.ioswifter.com/2016/04/18/notes-1/</id>
    <published>2016-04-18T08:55:14.000Z</published>
    <updated>2021-07-07T07:09:03.117Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Mac，iPhone，开发者账号，github购买了$7/month的plan。</p><p>定位：Twitter三方客户端，简单易用，页面简洁。</p><p>设计流程：idea；确立产品原型，项目评估，产品脑图，功能需求文档，创意，策划，调研；原型设计，UI/UE设计，效果图；研发；测试。</p><p>有太多的工作要做了，先简单的记录一下，以免忘记，之后不断补充。<br>SDK准备，接口调研；</p><p>1、名字。<br>起名字确实是个很难得问题。本着简单好记，没有太多歧义的前提，一个个的试，去App Store搜索，检索有没有被使用。最后决定使用Coo作为App的名字，如果想到更好的，大不了以后再换嘛。<br>2、icon<br>icon的重要程度几乎和名字差不多，之前只是按照教程使用Sketch简单的设计过，经验几乎为零。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;Mac，iPhone，开发者账号，github购买了$7/month的plan。&lt;/p&gt;
&lt;p&gt;定位：Twitter三方客户端，简单易用，页面简洁。&lt;/p&gt;
&lt;p&gt;设计流程：idea；确立产品原型，项目评估，产品脑图，功能</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>lldb and chisel</title>
    <link href="http://www.ioswifter.com/2016/03/27/lldb-and-chisel/"/>
    <id>http://www.ioswifter.com/2016/03/27/lldb-and-chisel/</id>
    <published>2016-03-27T10:02:41.000Z</published>
    <updated>2021-07-07T07:09:03.116Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>##lldb</p><p>p(print, pri, e - -)  打印<br>e(expression)      改变调试器和程序中的值<br>po(e -o - -)           对象description<br>p 16 默认格式；p/x 16  十六进制；p/t 16  二进制；p/c 16  字符；p/s 16  以空终止的字符串<br>变量     以$开头定义变量<br>(lldb) e int $a = 2<br>(lldb) p $a * 19<br>c(continue, process continue)<br>n(next, thread step-over)<br>s(step, thread step-in)<br>finish(tread step-out)<br>frame info             当前行数，源码文件<br>thread return          在开头伪造返回值<br>br li (breakpoint list) 断点列表<br>br dis(breakpoint disable) <breakpointID>       关闭断点<br>breakpint enable <breakpointID>  打开断点<br>br del <breakpointID>  删除断点<br>br s(breakpoint set) -f main.m -l 16</p><p>##chisel<br>pviews             递归打印所有的view<br>pvc                递归打印viewcontroller<br>visualise          截图、定位一个view的内容(UIImage,CGImageRef,UIView,CALayer)<br>fv fvc <name>      搜索当前内存中的view或viewcontroller<br>show/hide          显示/隐藏 view<br>mask/unmask        给view覆盖一层遮罩<br>border/unborder    给view加边框<br>bmessage           打断点<br>internals          打印控件类型的内部结构</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;##lldb&lt;/p&gt;
&lt;p&gt;p(print, pri, e - -)  打印&lt;br&gt;e(expression)      改变调试器和程序中的值&lt;br&gt;po(e -o - -)           对象descriptio</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Emacs Keyboard shortcut</title>
    <link href="http://www.ioswifter.com/2016/03/26/Emacs-Keyboard-shortcut/"/>
    <id>http://www.ioswifter.com/2016/03/26/Emacs-Keyboard-shortcut/</id>
    <published>2016-03-26T10:17:08.000Z</published>
    <updated>2021-07-07T07:09:03.115Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>emacs filename          打开文件<br>C-x C-c            退出<br>C-x C-f filename    打开文件<br>C-x C-s            保存文件<br>C-x u            取消上一次操作</p><p>q                取消执行<br>C-g                中断，取消当前命令或输入一半的命令</p><p>C-p        上<br>C-n        下<br>C-b        前<br>C-f        后<br>C-a        行首<br>C-e        行尾<br>C-l        重绘屏幕</p><p>C-v        下一页<br>M-v        上一页</p><p>M-f        下一单词<br>M-b        上一单词<br>M-a        句首<br>M-e        句尾</p><p>M-&lt;        档首<br>M-&gt;        档尾</p><p>C-u num cmd     重复执行cmd num次<br>C-u 8 C-f 向右移动8个字符<br>C-u 5 C-n 向下移动5行<br>C-u 10 C-x u  取消10次操作<br>C-u 3 C-v    上翻3行</p><p>C-d         删除光标所在字符<br>M-del    删除前一个单词<br>M-d        删除后一个单词<br>C-k        删除至行尾<br>M-k        删除至句尾</p><p>C-y         粘贴最近一次剪切的内容</p><p>C-z 或者 C-x C-z    挂起emacs，输入fg回到emacs界面</p><p>C+x+2<br>C+x+3<br>C+x+o<br>C+x+1<br>C+M+v</p><p>C+s+内容        向前搜索<br>C+r            向后搜索</p><p>C+@ 在两个位置按下，然后再按C+w，剪切两个位置之间的字符</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;emacs filename          打开文件&lt;br&gt;C-x C-c            退出&lt;br&gt;C-x C-f filename    打开文件&lt;br&gt;C-x C-s            保存文件&lt;br</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>程序员和设计师（摘录自《独立游戏者》）</title>
    <link href="http://www.ioswifter.com/2016/03/25/Programmer-and-Designer/"/>
    <id>http://www.ioswifter.com/2016/03/25/Programmer-and-Designer/</id>
    <published>2016-03-25T10:53:58.000Z</published>
    <updated>2021-07-07T07:09:03.116Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>程序员：我可能会坐下来，然后每周照样工作 70 个小时以上，用别人的引擎写脚本。因为要用到第三方的产品加速开发进度，那么我就必须明白一个道理，需要适当牺牲游戏品质来保证速度。这样一来，我感觉自己作为程序员的正直感没了，对新功能的开发热情也会逐渐褪去，我业余时间所做的一切也都归我的老板所有，对创新的激情也会逐渐丧失。</p><p>设计师：也许我正好够幸运，得到了一份自己感兴趣的工作，有大把的时间设计射击游戏，可以看着自己的作品成模，最后成为一个栩栩如生的游戏整体。但有一天，那个制作人、电脑白痴、游戏经验仅限于 Bejewelled 的二货过来告诉你“我 10 岁的小侄儿现在特喜欢矮种马，快把游戏改了吧，改成关于矮种马的”，你有什么办法?他是老板，只能听之任之，改游戏，放弃之前的创作，一切只因我受雇于人</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;程序员：我可能会坐下来，然后每周照样工作 70 个小时以上，用别人的引擎写脚本。因为要用到第三方的产品加速开发进度，那么我就必须明白一个道理，需要适当牺牲游戏品质来保证速度。这样一来，我感觉自己作为程序员的正直感没了，对新</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Carthage usage</title>
    <link href="http://www.ioswifter.com/2016/03/24/Carthage-usage/"/>
    <id>http://www.ioswifter.com/2016/03/24/Carthage-usage/</id>
    <published>2016-03-24T10:11:59.000Z</published>
    <updated>2021-07-07T07:09:03.114Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>Carthage 的使用 （只能iOS8以上使用）</p><p>1、创建一个Cartfile文件，包含需要的框架；<br>2、执行carthage update，拉取源代码并编译为Framework；<br>3、把编译后的 .framework 拖到项目中。</p><p>升级框架<br>carthage update</p><p><a href="http://www.cocoachina.com/ios/20141204/10528.html">http://www.cocoachina.com/ios/20141204/10528.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;Carthage 的使用 （只能iOS8以上使用）&lt;/p&gt;
&lt;p&gt;1、创建一个Cartfile文件，包含需要的框架；&lt;br&gt;2、执行carthage update，拉取源代码并编译为Framework；&lt;br&gt;3、把编译后</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Sketch Skill</title>
    <link href="http://www.ioswifter.com/2016/03/24/Sketch-Skill/"/>
    <id>http://www.ioswifter.com/2016/03/24/Sketch-Skill/</id>
    <published>2016-03-24T09:59:04.000Z</published>
    <updated>2021-07-07T07:09:03.116Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><ol><li>insert快捷键  V、P、T、A、S、L、R、O、U</li><li>alt                          从中心点绘制图形</li><li>shift                        正方形，圆形，45°的直线</li><li>command+0                    缩放100%<br>command+1                    查看画布全部设计<br>command+2                    缩放选中的对象</li><li>shift+滚轮                    滚动</li><li>command+option+1,2,3         隐藏左右面板</li><li>command+option+T             隐藏工具栏</li><li>command+.                    进入全屏模式</li><li>control+R                    显示标尺，点击标尺添加参考线，移动参考线到边上，删除参考线</li><li>alt                          显示margin<br>方向键                        移动选中的对象，<br>shift+方向键                  每次移动10px</li><li>command+方向键                可以改变对象的尺寸<br>command+shift+方向键          可以每次改变10px</li><li>command+R                    重命名</li><li>enter                       完成重命名</li><li>command+G                   新建组</li><li>commad+C, command+V         粘贴复制<br>command+D                   一步到位<br>alt+拖拽                    第一次复制</li><li>command+F                  搜    索图层</li><li>tap                        图层中切换</li><li>shift+command+H            图层隐藏/可见模式</li><li>shift+command+L            图层锁定/解锁模式</li><li><a href="http://www.sketchappsources.com/">http://www.sketchappsources.com</a> 查找资源<br>教程</li><li><a href="http://www.sketchcn.com/sketch-tips-tricks-2.html">http://www.sketchcn.com/sketch-tips-tricks-2.html</a></li><li><a href="http://www.sketchs.cn/manual/detail/206.html">http://www.sketchs.cn/manual/detail/206.html</a></li><li><a href="http://www.sketchcn.com/sketch-chinese-user-manual.html">http://www.sketchcn.com/sketch-chinese-user-manual.html</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;ol&gt;
&lt;li&gt;insert快捷键  V、P、T、A、S、L、R、O、U&lt;/li&gt;
&lt;li&gt;alt                          从中心点绘制图形&lt;/li&gt;
&lt;li&gt;shift               </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Clojure 学习笔记</title>
    <link href="http://www.ioswifter.com/2016/03/23/Clojure-note/"/>
    <id>http://www.ioswifter.com/2016/03/23/Clojure-note/</id>
    <published>2016-03-23T09:57:19.000Z</published>
    <updated>2021-07-07T07:09:03.115Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>；注释以分号开始<br>；Clojure 代码由一个个form组成，即写在小括号里有空格分开的一组语句<br>；Clojure解释器会把第一个元素当做一个函数或者一个宏来调用，其余被认为是参数</p><p>ns 指定命名空间 (ns noteclojure)</p><p>—————基本<br>str 创建字符串</p><ul><li><ul><li><ul><li>\ =<br>not 逻辑非</li></ul></li></ul></li></ul><p>—————类型<br>class 查看类型<br>‘ quote<br>eval 运算求值</p><p>—————集合<br>[] 数组<br>‘()链表 (list)<br>coll? 集合<br>seq? 序列<br>rang 序列 (range 4) ; =&gt; (0 1 2 3) , (range) ;=&gt;(0 1 2 3 …), (take 4 (range));=&gt;(0 1 2 3)<br>cons 列表或向量起始位置添加元素 (cons 4 [1 2 3]);=&gt;[4 1 2 3]<br>conj 更高效的添加元素 (conj [1 2 3] 4);=&gt;[1 2 3 4] ,(conj ‘(1 2 3) 4);=&gt; (4 1 2 3)<br>concat 合并列表或向量 (concat [1 2] ‘(3 4)); =&gt; (1 2 3 4)<br>filter 过滤集合元素 (filter even? [1 2 3]); =&gt; (2)<br>map 根据指定的函数映射到一个新的集合 (map inc [1 2 3]); =&gt; (2 3 4)<br>reduce 使用函数来规约集合 (reduce + [1 2 3 4]); = (+ (+ (+ 1 2) 3) 4); =&gt; 10<br>            指定一个初始参数 (reduce conj [] ‘(3 2 1)); = (conj (conj (conj [] 3) 2) 1); ==&gt; [3 2 1]</p><p>————–函数<br>fn 创建函数，返回值是最后一个表达式的值 (fn [] “Hello World”); =&gt; fn<br>    嵌套小括号来调用它 ((fn [] “Hello World”)); =&gt; “Hello World”<br>def 创建一个变量var  (def x 1)   x; =&gt; 1<br>      将函数定义为一个变量 (def hello-world (fn [] “Hello World”)) (hello -world); =&gt; “Hello World”<br>defn 简化函数定义  (defn hello-world [] “Hello World”)<br>        中括号的内容是函数的参数  (defn hello [name] (str “Hello” name))  (hello “Steve”)  ;=&gt;”Hello Steve”<br>    简写  (def hello2 #(str “Hello” %1))  (hello2 “Fanny”)<br>    多个参数列表 (defn hello3 ([] “Hello wolrd”) ([name] (str “Hello “ name)))  (hello3 “Jake”);=&gt;”Hello Jake”<br>        (hello3);=&gt; “Hello World”<br>    可以定义变参函数，即把&amp;后面的参数全部放入一个序列<br>    (defn count-args [&amp; args] (str “You passed “ (count args) “ args: “))  (count-args 1 2 3) ;=&gt; “You passed 3 args: (1 2 3)”<br>    可以混用定参和变参（用&amp;来界定）(defn hello-count [name &amp; args] (str “Hello ” name “, you passed “ (count args) “ extra args”))   (hello-count “Finn” 1 2 3) ;=&gt; “Hello Finn, you passed 3 extra args”</p><p>————–哈希表<br>；基于hash的map和基于数组的map（即array map），实现了相同的接口，hash map查询比较快，但不保证元素顺序<br>(class {:a 1 :b 2 :c 3})<br>(class (hash-map :a 1 :b 2 :c 3))<br>arraymap在足够大的时候，大多数操作会将其自动转换成hashmap<br>(def stringmap {“a” 1, “b” 2, “c” 3})   stringmap   ;=&gt; {“a” 1, “b” 2, “c” 3}   逗号可有可无<br>(def keymap {:a 1, :b 2, :c 3})   keymap   ;=&gt; {:a 1, :c 3, :b 2}<br>(stringmap “a”)    (keymap :a)   (:b keymap)  (stringmap “d”);=&gt; nil  从map查找元素</p><p>assoc 函数来向hashmap添加元素  (def newkeymap (assoc keymap :d 4))   newkemap<br>          newkeymap ;=&gt; {:a 1, :b 2, :c 3, :d 4}   keymap ;=&gt; {:a 1, :b 2, :c 3}  数据类型不可变<br>dissoc 移除元素    (dissoc keymap :a :b) ;=&gt; {:c 3}</p><p>————–集合set  #<br>(class #{1 2 3}) ;=&gt; clojure.lang.PersistentHashSet<br>(set [1 2 3 1 2 3 3 2 1 3 2 1]) ;=&gt; #{1 2 3}<br>conj 新增元素  (conj #{1 2 3} 4)  ;=&gt; #{1 2 3 4}<br>disj  移除元素  (disj #{1 2 3} 1)   ; =&gt; #{2 3}<br>(#{1 2 3} 1)   ;=&gt; 1   (#{1 2 3} 4)  ;=&gt; nil 把集合当做函数调用来检查元素是否存在</p><p>—————常用的form<br>macro  clojure里的逻辑控制结构都是用宏实现的<br>            (if false “a” “b”)  ;=&gt; “b”<br>            (if false “a”) ;=&gt; nil<br>let        来创建临时的绑定变量  (let [a 1 b 2] (&gt; a b))   ; =&gt; false<br>do        将多个语句组合在一起依次执行  (do (print “Hello”) “World”)  ;=&gt; “World” (spring “Hello”)<br>        函数定义里有一个隐式的do<br>(defn print-and-say-hello [name]<br>  (print “Saying hello to “ name)<br>  (str “Hello “ name) )<br>(pring-and-say-hello “Jeff”)   ;=&gt; “Hello Jeff” (prints “Saying hello to Jeff”);<br>        let也是如此<br>(let [name “burgle”]<br>  (pring “Saying hello to ” name)<br>  (str “Hello ” name) )  ; =&gt; “Hello Urkel” (prints “Saying hello to Urkel”)</p><p>—————模块<br>use  用来导入模块里的所有函数<br>        (use ‘clojure.set)<br>        然后可以使用set相关的函数了<br>        (intersection #{1 2 3} #{2 3 4})  ; =&gt; #{2 3}<br>        (difference #{1 2 3} #{2 3 4}) ; =&gt; #{1}</p><pre><code>    也可以从一个模块里导入一部分函数    (use ‘[clojure.set :only [intersection]])</code></pre><p>require  用来导入一个模块    (require ‘clojure.string)<br>/           用来调用模块里的函数   (clojure.string/blank? “”)  ;=&gt; true<br>            在’import’里可以给模块名指定一个较短的别名<br>            (require ‘[clojure.string :as str])  (str/replace “This is a test.” #”[a-o]” str /upper-case) ;=&gt; “THIs Is A tEst.”</p><p>#””       用来表示一个正则表达式</p><p>:require 可以在一个namespace定义里用:require的方式来require模块（或use，但最好不要用）<br>(ns test<br>  (:require<br>    [clojure.string :as str]<br>    [clojure.set :as set] ))</p><p>—————-java<br>import    导入java类   (import java.util.Date)<br>(ns test<br>  (:import java.util.Date<br>               java.util.Calendar ))<br>(Date.)  用类名末尾加’.’的方式来new一个java对象<br>    用’.’操作符来调用方法，或用’.method’的简化方式<br>(. (Date.) getTime)           (.getTime (Date.))<br>    用’/‘调用静态方法<br>(System/currentTimeMillis)<br>    用’doto’来更方便的使用（可变）类<br>(import java.util.Calendar)<br>(doto (Calendar/getInstance)<br>  (.set 2000 1 1 0 0 0)<br>  .getTime )   ;=&gt; A Date. set to 2000-01-01 00:00:00</p><p>—————————STM<br>软件内存事务（Software Transactional Memory） 被clojure用来处理持久化的状态</p><p>atom   atom是最简单的 (def my-atom (atom {}))<br>swap!  更新atom   (swap! my-atom assoc :a 1) ;=&gt; (assoc {} :a 1)<br>                             (swap! my-atom assoc :b 2) ;=&gt; (assoc {:a 1} :b 2)<br>@        读取atom的值  @my-atom   ;=&gt; {:a 1 :b 2}</p><p>下例是一个使用atom实现的简单计数器<br>(def counter (atom 0))<br>(def inc-counter []<br>  (swap! counter inc))</p><p>(inc-counter)<br>(inc-counter)<br>(inc-counter)</p><p>@counter   ;=&gt;5</p><p>其他STM相关的结构是ref和agent</p><p>clojure macros</p><p>defmacro   定义宏。宏应该输出一个可以作为clojure代码演算的列表<br>(defmacro my-first-macro []<br>  (list reverse “Hello World”))   ; =&gt; (reverse “Hello World”)</p><p>使用macroexpand或macroexpand-1查看宏的结果，注意调用需要引用<br>(macroexpand ‘(my-first-macro))</p><p>可以直接 eval macroexpand 的结果<br>(eval (macroexpand ‘(my-first-macro)))   ; =&gt; (\d \l \o \r \W \space \o \l \l \e \H)<br>(my-first-macro)  ; =&gt; 同上</p><p>创建宏的时候可以使用更简短的引用形式来创建列表<br>(defamer my-first-quoted-macro []<br>  ‘(reverse “Hello World”) )</p><p>(macroexpand ‘(my-first-quoted-macro))  ; =&gt; (reverse “Hello World”)  注意reverse不再是一个函数对象，而是一个符号</p><p>宏可以传入参数<br>(defmacro inc2 [arg]<br>  (list + 2 arg))</p><p>(inc2 2)  ; =&gt; 4</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;


&lt;p&gt;；注释以分号开始&lt;br&gt;；Clojure 代码由一个个form组成，即写在小括号里有空格分开的一组语句&lt;br&gt;；Clojure解释器会把第一个元素当做一个函数或者一个宏来调用，其余被认为是参数&lt;/p&gt;
&lt;p&gt;ns 指定命名</summary>
      
    
    
    
    
  </entry>
  
</feed>
